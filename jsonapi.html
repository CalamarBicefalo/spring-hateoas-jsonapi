<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<title>JSON:API</title>
<link rel="stylesheet" href="css/spring.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
</head>
<body id="mediatypes.jsonapi" class="article">
<div id="header">
<h1>JSON:API</h1>
<div class="details">
<span id="revnumber">version 0.0.1-SNAPSHOT</span>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://jsonapi.org/">JSON:API</a> is a widely adapted hypermedia format.
You can find a list of implementations and tools <a href="https://jsonapi.org/implementations/">here</a>.
Answers to a few questions, e.g. related to HAL, you can find
<a href="https://jsonapi.org/faq/#why-not-use-the-hal-specification">here</a>.</p>
</div>
<div class="paragraph">
<p>To enable JSON:API for Spring HATEOAS, just put com.toedter.spring.hateoas.jsonapi.0.0.1-SNAPSHOT.jar in your classpath.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The jar is not published to Maven Central yet. I will wait until the API keeps being more stable.
(Or, if accepted by the Spring HATEOAS team, contribute the implementation to the Spring HATEOAS project).
For now, you have to clone the Gitbub project <a href="https://github.com/toedter/spring-hateoas-jsonapi" class="bare">https://github.com/toedter/spring-hateoas-jsonapi</a>
and build the jar locally.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Anytime a client supplies an <code>Accept</code> header with <code>application/vnd.api+json</code>, you can expect something like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
  "jsonapi": {
    "version": "1.0"
  },
  "data": {
    "id": "1",
    "type": "movies",
    "attributes": {
      "title": "The Shawshank Redemption",
      "year": 1994,
      "rating": 9.3
    },
    "relationships": {
      "directors": {
        "data": {
          "id": "2",
          "type": "directors"
        }
      }
    },
    "links": {
      "self": "http://localhost:8080/api/movies/1",
      "movies": "http://localhost:8080/api/movies{?page[number],page[size]}"
    }
  },
  "included": {
    "id": "2",
    "type": "directors",
    "attributes": {
      "name": "Frank Darabont"
    }
  },
  "links": {
    "self": "http://localhost:8080/api/movies?page[number]=0,page[size]=1",
    "next": "http://localhost:8080/api/movies?page[number]=1&amp;page[size]=1",
    "last": "http://localhost:8080/api/movies?page[number]=249&amp;page[size]=1"
  },
  "meta": {
    "page": {
      "number": 0,
      "size": 1,
      "totalPages": 250,
      "totalElements": 250
    }
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_representation_models">Representation Models</h2>
<div class="sectionbody">
<div class="paragraph">
<p>All Spring HATEOAS representation models are rendered as JSON:API.
Consider a simple Movie Class as base for a Spring HATEOAS entity model:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Data
@NoArgsConstructor
@AllArgsConstructor
@With
public class Movie {
    private String id;
    private String title;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>An <code>EnitiyModel.of(new Movie("1", "Star Wars"))</code> is then rendered as</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
  "data": {
    "id": "1",
    "type": "movies",
    "attributes": {
      "title": "Star Wars"
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In JSON:API, the <code>id</code> field must be of type <code>String</code>.
But in your model you can use any Class and <code>toString()</code> is used for conversion.
So, if the <code>id</code> attribute of <code>Movie</code> would be of type <code>long</code>,
the rendered JSON:API would be the same.
The JSON:API <code>type</code> is automtically generated of the pluralized, lower case, simple class name.
This is best practice, since then most likely the type matches the URL (end)
of the corresponding REST collection resource.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You can configure if you want to use non-pluralized class names, see <a href="#configuration">Configuration</a>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_annotations">Annotations</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The goal of this implementation is to automate the mapping from/to JSON:API
as convenient as possible for the developer.</p>
</div>
<div class="paragraph">
<p>There are two new Annotations provided by this project:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>@JsonApiId</code> to mark a JSON:API <code>id</code></p>
</li>
<li>
<p><code>@JsonApiType</code> to mark a JSON:API <code>type</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The use of these annotations is optional. For the mapping of the <code>id</code>, the
following rules apply in order:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the annotation <code>@JsonApiId</code> is used on a field</p>
</li>
<li>
<p>the annotation <code>@JsonApiId</code> is used on a method</p>
</li>
<li>
<p>the annotation <code>@Id</code> (javax.persistence.Id) is used on a field</p>
</li>
<li>
<p>the annotation <code>@Id</code> (javax.persistence.Id) is used on a method</p>
</li>
<li>
<p>the entity (base for representation models) provides an attribute <code>id</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For the mapping of the <code>type</code>, the
following rules apply in order:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the annotation <code>@JsonApiType</code> is used on a field</p>
</li>
<li>
<p>if no annotation is present, the pluralized, lower case, simple class name of the entity will be used</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You can configure if you want to use non-pluralized class names, see <a href="#configuration">Configuration</a>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>As an example, consider the class</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class Movie2 {
    @Id
    private String myId;
    private String title;
    @JsonApiType
    private String type;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then, <code>EntityModel.of(new Movie2("1", "Star Wars", "my-movies")))</code> will be rendered as</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
  "data": {
    "id": "1",
    "type": "my-movies",
    "attributes": {
      "title": "Star Wars"
    }
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_jsonapi_builder">JSON:API Builder</h2>
<div class="sectionbody">
<div class="paragraph">
<p>If you want to use JSON:API <code>relationships</code> or <code>included</code> data, you can use the
<code>JsonApiModelBuilder</code>. The following example shows how to create a JSON::API representation model using the <code>JsonApiModelBuilder</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import static com.toedter.spring.hateoas.jsonapi.JsonApiModelBuilder.jsonApiModel;
import static org.junit.jupiter.api.Assertions.assertThrows;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Movie movie = new Movie("1", "Star Wars");
final RepresentationModel&lt;?&gt; jsonApiModel = jsonApiModel().model(movie).build();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Consider that you want to express the relationships of movies to their directors.
A simple <code>Director</code> class could look like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Data
@NoArgsConstructor
@AllArgsConstructor
@With
public class Director {
    private String id;
    private String name;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can build a relationship from a movie to a director like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Movie movie = new Movie("1", "Star Wars");
Director director = new Director("1", "George Lucas");
final RepresentationModel&lt;?&gt; jsonApiModel =
        jsonApiModel().model(movie)
                .relationship("directors", EntityModel.of(director))
                .build();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The representation model will be rendered as</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">{
  "data": {
    "id": "1",
    "type": "movies",
    "attributes": {
      "title": "Star Wars"
    },
    "relationships": {
      "directors": {
        "data": {
          "id": "1",
          "type": "directors"
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you want to include the related resources in the JSON:API output,
you can build included director resources like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Movie movie = new Movie("1", "The Matrix");
Movie relatedMovie = new Movie("2", "The Matrix 2");
Director director1 = new Director("1", "Lana Wachowski");
Director director2 = new Director("2", "Lilly Wachowski");

final RepresentationModel&lt;?&gt; jsonApiModel =
        jsonApiModel().model(movie)
                .relationship("directors", director1)
                .relationship("directors", director2)
                .relationship("relatedMovies", EntityModel.of(relatedMovie))
                .included(director1)
                .included(director2)
                .build();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The representation model will be rendered as</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">{
  "data": {
    "id": "1",
    "type": "movies",
    "attributes": {
      "title": "The Matrix"
    },
    "relationships": {
      "relatedMovies": {
        "data": {
          "id": "2",
          "type": "movies"
        }
      },
      "directors": [
        {
          "data": {
            "id": "1",
            "type": "directors"
          }
        },
        {
          "data": {
            "id": "2",
            "type": "directors"
          }
        }
      ]
    }
  },
  "included": [
    {
      "id": "1",
      "type": "directors",
      "attributes": {
        "name": "Lana Wachowski"
      }
    },
    {
      "id": "2",
      "type": "directors",
      "attributes": {
        "name": "Lilly Wachowski"
      }
    }
  ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows the creation of a more complex
JSON:API specific representation model with a paged model as base.
The builder supports adding both pagination metadata and pagination links.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Movie movie = new Movie("1", "The Matrix");
Movie relatedMovie = new Movie("2", "The Matrix 2");
Director director1 = new Director("1", "Lana Wachowski");
final EntityModel&lt;Director&gt; director1EntityModel = EntityModel.of(director1);
Director director2 = new Director("2", "Lilly Wachowski");
final EntityModel&lt;Director&gt; director2EntityModel = EntityModel.of(director2);

final RepresentationModel&lt;?&gt; jsonApiModel1 =
        jsonApiModel()
                .model(movie)
                .relationship("directors", director1EntityModel)
                .relationship("directors", director2EntityModel)
                .relationship("relatedMovies", EntityModel.of(relatedMovie))
                .build();

Movie movie2 = new Movie("3", "Star Wars");
Director director3 = new Director("3", "George Lucas");
final EntityModel&lt;Director&gt; director3EntityModel = EntityModel.of(director3);

final RepresentationModel&lt;?&gt; jsonApiModel2 =
        jsonApiModel()
                .model(movie2)
                .relationship("directors", director3EntityModel)
                .build();

List&lt;RepresentationModel&lt;?&gt;&gt; movies = new ArrayList&lt;&gt;();
movies.add(jsonApiModel1);
movies.add(jsonApiModel2);

PagedModel.PageMetadata pageMetadata = new PagedModel.PageMetadata(2, 1, 100, 50);
Link selfLink = Link.of("http://localhost/movies").withSelfRel();
final PagedModel&lt;RepresentationModel&lt;?&gt;&gt; pagedModel = PagedModel.of(movies, pageMetadata, selfLink);

RepresentationModel&lt;?&gt; pagedJasonApiModel =
        jsonApiModel()
                .model(pagedModel)
                .included(director1EntityModel)
                .included(director2EntityModel)
                .pageMeta()
                .pageLinks("http://localhost/movies")
                .build();</code></pre>
</div>
</div>
<div class="paragraph">
<p>This model will be rendered as</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
  "data": [
    {
      "id": "1",
      "type": "movies",
      "attributes": {
        "title": "The Matrix"
      },
      "relationships": {
        "relatedMovies": {
          "data": {
            "id": "2",
            "type": "movies"
          }
        },
        "directors": [
          {
            "data": {
              "id": "1",
              "type": "directors"
            }
          },
          {
            "data": {
              "id": "2",
              "type": "directors"
            }
          }
        ]
      }
    },
    {
      "id": "3",
      "type": "movies",
      "attributes": {
        "title": "Star Wars"
      },
      "relationships": {
        "directors": {
          "data": {
            "id": "3",
            "type": "directors"
          }
        }
      }
    }
  ],
  "included": [
    {
      "id": "1",
      "type": "directors",
      "attributes": {
        "name": "Lana Wachowski"
      }
    },
    {
      "id": "2",
      "type": "directors",
      "attributes": {
        "name": "Lilly Wachowski"
      }
    }
  ],
  "links": {
    "self": "http://localhost/movies",
    "first": "http://localhost/movies?page[number]=0&amp;page[size]=2",
    "prev": "http://localhost/movies?page[number]=0&amp;page[size]=2",
    "next": "http://localhost/movies?page[number]=2&amp;page[size]=2",
    "last": "http://localhost/movies?page[number]=49&amp;page[size]=2"
  },
  "meta": {
    "page": {
      "number": 1,
      "size": 2,
      "totalPages": 50,
      "totalElements": 100
    }
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="configuration">Configuration</h2>
<div class="sectionbody">
<div class="paragraph">
<p>There are several options how to change the output of the JSON:API rendering.</p>
</div>
<div class="paragraph">
<p>For a specific JSON:API configuration, you can create a Spring bean of type JsonApiConfiguration.
Currently, you can configure</p>
</div>
<div class="ulist">
<ul>
<li>
<p>if the JSON:API version should be rendered automatically, the default is <code>false</code>.</p>
</li>
<li>
<p>if JSON:API types should be rendered as non pluralized class names.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Since the JSON:API recommendation contains square brackets in the request parameter names,
make sure that you provide the following configuration in your Spring <code>application.properties</code> when using Tomcat:
<code>server.tomcat.relaxed-query-chars= [,]</code>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Here is an example how you would implement a JSON:API configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">@Bean
JsonApiConfiguration jsonApiConfiguration() {
    return new JsonApiConfiguration()
            .withJsonApiVersionRendered(true)
            .withPluralizedTypeRendered(false);
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 0.0.1-SNAPSHOT<br>
Last updated 2020-06-23 17:59:49 UTC
</div>
</div>
<script type="text/javascript" src="js/tocbot/tocbot.min.js"></script>
<script type="text/javascript" src="js/toc.js"></script>
</body>
</html>